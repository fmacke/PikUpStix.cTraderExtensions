using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using NUnit.Framework;


namespace Application.Tests
{
    //[TestFixture]
    //public class ForecastTestsUsingPython
    //{
    //    private List<HistoricalData> data;
    //    [OneTimeSetUp]
    //    public void Init()
    //    { 
             
    //    }
    //    [Test]
    //    public void Calculate_Combined_Scaled_Capped_Forecast()
    //    {
    //        if (data == null)
    //            LoadData();
    //        var forecast16_64 = new EwmacForecast(16, 64, data);
    //        var forecast32_128 = new EwmacForecast(32, 128, data);
    //        var forecast64_256 = new EwmacForecast(64, 256, data);
    //        var shortForecast = forecast16_64.GetScaledForecast().Forecast;
    //        var mediumForecast = forecast32_128.GetScaledForecast().Forecast;
    //        var longForecast = forecast64_256.GetScaledForecast().Forecast;
    //        var combinedForecast = new SingleInstrumentCombinedForecast(shortForecast, mediumForecast, longForecast);
    //        Assert.AreEqual(-13.320916565243920930590707475m, combinedForecast.CombinedForecast);
    //    }

    //    [Test]
    //    public void Calculate_Forecast_Scalar_Using_ExcelFile()
    //    {
    //        if (data == null)
    //            LoadData();
    //        var forecast = new EwmacForecast(16, 64, data);
    //        var forecastScalar = new ForecastScaling();
    //        Assert.AreEqual(4.4340942932941627055238502878m, forecastScalar.GetForecastScalar(forecast.GetUnscaledForecast()));
    //    }

    //    private void LoadData()
    //    {
    //        data = ExcelConnector.GethHistoricalPrices(@"C:\dev\PikUpStix.Trading\PikUpStix.Trading.NTests\CsvData\CME_BP1 - British Pound Futures (Front Month) to 20170122 - SMALL.xlsx");
    //    }

    //    [Test]
    //    [Ignore("Calls Quandl for new data")]
    //    public void Get_Forecast_Using_Quandl()
    //    {
    //        var instrs = new List<Instrument>
    //        {
    //            new Instrument()
    //            {
    //                DataName = "CME_BP1",
    //                DataSource = "CHRIS",
    //                InstrumentId = 1
    //            }
    //        };
    //        var data = QuandlConnector.GetData(true, new DateTime(1974, 1, 1), instrs);
    //        var forecast = new EwmacForecast(2, 8, data.First());
    //        var outcome = forecast.GetScaledForecast();
    //        Assert.That(outcome.Forecast > -21 || outcome.Forecast < 21);
    //        Console.WriteLine(forecast.Forecastname + "(based on last data at " + outcome.DateTime.ToShortDateString() + ") is: " + outcome.Forecast);
    //    }
    //    /// <summary>
    //    /// This gets test data from Carver's csv and checks forecast figures against figures generated by Carver's own system.  In short, if this test
    //    /// is working, it indicates that the system is making identical single instrument, unscaled, uncapped forecasts
    //    /// </summary>
    //    [Test]
    //    public void Get_Forecast_Using_CsvData()
    //    {
    //        var noOfTestsRun = 0;
    //        var priceData = GetCsvList();
    //        var forecast = new EwmacForecast(2, 8, priceData);
    //        var dict = forecast.GetUnscaledForecast();
    //        const int noOfTestToConfirm = 9;
    //        foreach (var result in dict)
    //        {
    //            // These test figures could actually be in a dictionary of their own
    //            if (result.DateTime.Year == 1983 && result.DateTime.Month == 10 && result.DateTime.Day == 10)
    //                noOfTestsRun += CheckResult(result.Forecast, Convert.ToDecimal(0.6959288));
    //            if (result.DateTime.Year == 1983 && result.DateTime.Month == 10 && result.DateTime.Day == 12)
    //                noOfTestsRun += CheckResult(result.Forecast, Convert.ToDecimal(-0.536305));
    //            if (result.DateTime.Year == 1983 && result.DateTime.Month == 10 && result.DateTime.Day == 18)
    //                noOfTestsRun += CheckResult(result.Forecast, Convert.ToDecimal(0.556449));
    //            if (result.DateTime.Year == 1983 && result.DateTime.Month == 10 && result.DateTime.Day == 27)
    //                noOfTestsRun += CheckResult(result.Forecast, Convert.ToDecimal(-0.749387));
    //            if (result.DateTime.Year == 2016 && result.DateTime.Month == 6 && result.DateTime.Day == 20)
    //                noOfTestsRun += CheckResult(result.Forecast, Convert.ToDecimal(0.006703));
    //            if (result.DateTime.Year == 2016 && result.DateTime.Month == 6 && result.DateTime.Day == 28)
    //                noOfTestsRun += CheckResult(result.Forecast, Convert.ToDecimal(1.556547));
    //            if (result.DateTime.Year == 2016 && result.DateTime.Month == 7 && result.DateTime.Day == 1)
    //                noOfTestsRun += CheckResult(result.Forecast, Convert.ToDecimal(0.774039));
    //            if (result.DateTime.Year == 2016 && result.DateTime.Month == 7 && result.DateTime.Day == 4)
    //                noOfTestsRun += CheckResult(result.Forecast, Convert.ToDecimal(0.679863));
    //            if (result.DateTime.Year == 2016 && result.DateTime.Month == 7 && result.DateTime.Day == 8)
    //                noOfTestsRun += CheckResult(result.Forecast, Convert.ToDecimal(0.746191));
    //        }
    //        Assert.AreEqual(noOfTestsRun, noOfTestToConfirm);
    //    }

    //    private static int CheckResult(Decimal result, Decimal confirmedTestValue)
    //    {
    //        Assert.AreEqual(Math.Round(result, 6, MidpointRounding.AwayFromZero), Math.Round(confirmedTestValue, 6, MidpointRounding.AwayFromZero));
    //        return 1;
    //    }

    //    private List<HistoricalData> GetCsvList()
    //    {
    //        var reader = new StreamReader(File.OpenRead(@"C:\dev\PikUpStix.Trading\PikUpStix.Trading.NTests\CsvData\EDOLLAR_price.csv"));
    //        var listA = new List<HistoricalData>();
    //        var firstLine = true;

    //        while (!reader.EndOfStream)
    //        {
    //            var line = reader.ReadLine();
    //            var values = line.Split(',');
    //            if (!firstLine)
    //            {
    //                string date = values[0].Substring(8, 2) + "/" + values[0].Substring(5, 2) + "/" +
    //                                  values[0].Substring(0, 4);
    //                try
    //                {
    //                    listA.Add(new HistoricalData()
    //                    {
    //                        Date = Convert.ToDateTime(date),
    //                        ClosePrice = Convert.ToDecimal(values[1])
    //                    });
    //                }
    //                catch (Exception ex)
    //                {
    //                    listA.Add(new HistoricalData()
    //                    {
    //                        Date = Convert.ToDateTime(date)
    //                    });
    //                }

    //            }
    //            firstLine = false;
    //        }
    //        return listA;
    //    }

    //    private PyList GetStaticList()
    //    {
    //        PyList list = new PyList();
    //        list.Append(new PyFloat(60.77));
    //        list.Append(new PyFloat(58.31));
    //        list.Append(new PyFloat(55.65));
    //        list.Append(new PyFloat(56.29));
    //        list.Append(new PyFloat(56.08));
    //        list.Append(new PyFloat(53.95));
    //        list.Append(new PyFloat(51.91));
    //        list.Append(new PyFloat(52.96));
    //        list.Append(new PyFloat(51.23));
    //        list.Append(new PyFloat(52.3));
    //        list.Append(new PyFloat(50.51));
    //        list.Append(new PyFloat(51.98));
    //        list.Append(new PyFloat(51.11));
    //        list.Append(new PyFloat(53.61));
    //        list.Append(new PyFloat(54.24));
    //        list.Append(new PyFloat(53.49));
    //        list.Append(new PyFloat(55.38));
    //        list.Append(new PyFloat(54.01));
    //        list.Append(new PyFloat(57.03));
    //        list.Append(new PyFloat(58.17));
    //        list.Append(new PyFloat(57.35));
    //        list.Append(new PyFloat(59.01));
    //        list.Append(new PyFloat(58.69));
    //        list.Append(new PyFloat(58.91));
    //        list.Append(new PyFloat(57.75));
    //        list.Append(new PyFloat(59.76));
    //        list.Append(new PyFloat(59.86));
    //        list.Append(new PyFloat(57.76));
    //        list.Append(new PyFloat(58.98));
    //        list.Append(new PyFloat(58));
    //        list.Append(new PyFloat(57.92));
    //        list.Append(new PyFloat(59.38));
    //        list.Append(new PyFloat(58.32));
    //        list.Append(new PyFloat(59.4));
    //        list.Append(new PyFloat(60.28));
    //        list.Append(new PyFloat(60.28));
    //        list.Append(new PyFloat(61.41));
    //        list.Append(new PyFloat(61.46));
    //        list.Append(new PyFloat(61.78));
    //        list.Append(new PyFloat(61.97));
    //        list.Append(new PyFloat(61.58));
    //        list.Append(new PyFloat(60.05));
    //        list.Append(new PyFloat(60.66));
    //        list.Append(new PyFloat(61.85));
    //        list.Append(new PyFloat(61.63));
    //        list.Append(new PyFloat(60.06));
    //        list.Append(new PyFloat(58.94));
    //        list.Append(new PyFloat(58.03));
    //        list.Append(new PyFloat(58.15));
    //        list.Append(new PyFloat(57.52));
    //        list.Append(new PyFloat(57.06));
    //        list.Append(new PyFloat(56.65));
    //        list.Append(new PyFloat(56.41));
    //        list.Append(new PyFloat(56.98));
    //        list.Append(new PyFloat(60.21));
    //        list.Append(new PyFloat(61.07));
    //        list.Append(new PyFloat(61.77));
    //        list.Append(new PyFloat(62.98));
    //        list.Append(new PyFloat(64.11));
    //        list.Append(new PyFloat(66.1));
    //        list.Append(new PyFloat(65.94));
    //        list.Append(new PyFloat(66.03));
    //        list.Append(new PyFloat(64.59));
    //        list.Append(new PyFloat(64.4));
    //        list.Append(new PyFloat(64.26));
    //        list.Append(new PyFloat(61.51));
    //        list.Append(new PyFloat(61.92));
    //        list.Append(new PyFloat(61.98));
    //        list.Append(new PyFloat(63.87));
    //        list.Append(new PyFloat(63.63));

    //        return list;
    //    }
    //}
}